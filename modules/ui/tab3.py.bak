# Interfaccia utente per la Tab 3 (Calcolo Presenze ed Esportazione)
import streamlit as st
import pandas as pd
import re
from datetime import datetime, date
from io import BytesIO
from modules.attendance import calculate_attendance

# Definisco le funzioni di utilit√† direttamente qui per evitare problemi di importazione
def clean_sheet_name(name):
    """Pulisce i nomi dei fogli Excel"""
    name = re.sub(r'[\\/?*\[\]:]', '', str(name))
    return name[:31]
    
def extract_code_from_parentheses(text):
    """Estrae codici tra parentesi"""
    if not isinstance(text, str): return None
    match = re.search(r'\((.*?)\)', text)
    if match:
        code = match.group(1).strip()
        if code: return code
    return None

def extract_sort_key(percorso_str):
    """Estrai chiavi di ordinamento dai percorsi"""
    code_match = re.search(r'^\[([-\w]+)\]', str(percorso_str))
    if code_match:
        return code_match.group(1)
    return str(percorso_str)

def render_tab3(df_main):
    """Renderizza l'interfaccia della Tab 3: Calcolo Presenze ed Esportazione"""
    st.header("üìä Calcolo Presenze ed Esportazione")
    
    # Utilizzo di container per una migliore organizzazione visiva
    info_container = st.container()
    with info_container:
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write("Visualizzazione presenze per studente e percorso con possibilit√† di esportazione dettagliata.")
        with col2:
            if st.session_state.duplicates_removed: 
                st.success("Dati depurati ‚úÖ", icon="‚úÖ")

    current_df_for_tab3 = df_main

    if not current_df_for_tab3.empty:
        required_att_cols = ['CodiceFiscale', 'PercorsoOriginaleSenzaArt13Internal', 'PercorsoInternal', 'PercorsoOriginaleInternal']
        if not all(col in current_df_for_tab3.columns for col in required_att_cols):
            missing_cols = [col for col in required_att_cols if col not in current_df_for_tab3.columns]
            st.error(f"Impossibile procedere: colonne mancanti ({', '.join(missing_cols)})")
            attendance_df = pd.DataFrame() # Resetta per sicurezza
        else:
            # Calcolo presenze usando la visualizzazione per studente e percorso
            with st.spinner("Calcolo delle presenze in corso..."):
                group_by = "studente"
                attendance_df = calculate_attendance(current_df_for_tab3, group_by=group_by)
            
            # Se abbiamo dati validi, mostriamo i filtri in un container ben organizzato
            if not attendance_df.empty:
                filter_container = st.container()
                with filter_container:
                    st.subheader("üîç Filtri", divider="gray")
                    st.caption("I filtri consentono di ridurre i dati visualizzati nelle tabelle sottostanti")
                    p_col_disp_key = "Percorso (Senza Art.13)"
                    p_col_internal_key = 'PercorsoOriginaleSenzaArt13Internal'
            
                # La logica per il filtraggio per studente e percorso
                if not attendance_df.empty:
                    if p_col_disp_key not in attendance_df.columns:
                        st.error(f"Colonna chiave '{p_col_disp_key}' non trovata nei dati aggregati.")
                    elif p_col_internal_key not in current_df_for_tab3.columns:
                        st.error(f"Colonna chiave interna '{p_col_internal_key}' non trovata nei dati dettagliati.")
                    # CORREZIONE: Questo else deve coprire tutto il blocco try/except successivo
                    else:
                        try:
                            # --- Filtro Percorso ---
                            # Prepara la lista di percorsi per il selettore, garantendo che i codici siano visualizzati all'inizio
                            perc_list = sorted([str(p) for p in attendance_df[p_col_disp_key].unique() if pd.notna(p)])
                            # Ordina percorsi in base ai codici tra parentesi quadre se presenti
                            perc_list = sorted(perc_list, key=extract_sort_key)
                            
                            # Statistica totale percorsi
                            st.caption(f"üìç Trovati {len(perc_list)} percorsi distinti")
                            
                        except Exception as e:
                            st.error(f"Errore nella preparazione dei filtri: {e}")
                            perc_list = []
                            
                        # Migliora la visualizzazione del filtro per percorso
                        filter_col1, filter_col2 = st.columns([3, 1])
                        with filter_col1:
                            perc_sel = st.selectbox(f"üìö Seleziona Percorso:", ["Tutti"] + perc_list, key="filt_perc_tab3_v7")
                        
                        # --- Filtro per Codice Classe di concorso ---
                        st.divider()
                        filter_concorso_col1, filter_concorso_col2 = st.columns([3, 1])
                        codice_concorso_sel = "Tutti"
                        
                        try:
                            # Ottieni tutti i codici classe di concorso unici dal dataframe
                            if 'Codice_Classe_di_concorso' in attendance_df.columns:
                                codice_concorso_list = sorted([str(c) for c in attendance_df['Codice_Classe_di_concorso'].unique() if pd.notna(c)])
                                
                                # Visualizza il filtro per codice classe di concorso
                                with filter_concorso_col1:
                                    codice_concorso_sel = st.selectbox(f"üè´ Seleziona Codice Classe di concorso:", 
                                                                     ["Tutti"] + codice_concorso_list, 
                                                                     key="filt_codice_concorso_tab3")
                                
                                # Mostra il numero di studenti per questo codice classe di concorso
                                if codice_concorso_sel != "Tutti":
                                    with filter_concorso_col2:
                                        studenti_per_codice = len(attendance_df[attendance_df['Codice_Classe_di_concorso'] == codice_concorso_sel])
                                        st.metric("Studenti nel codice", studenti_per_codice)
                            else:
                                with filter_concorso_col1:
                                    st.warning("Colonna 'Codice_Classe_di_concorso' non presente nei dati")
                        except Exception as e:
                            st.error(f"Errore nel filtro codice classe di concorso: {e}")
                        
                        # --- Filtro per Denominazione Attivit√† ---
                        filter_denominazione_col1, filter_denominazione_col2 = st.columns([3, 1])
                        denominazione_sel = "Tutte"
                        
                        try:
                            # Ottieni tutte le denominazioni attivit√† uniche dal dataframe dettagliato
                            if 'DenominazioneAttivit√†' in current_df_for_tab3.columns:
                                denominazione_list = sorted([str(d) for d in current_df_for_tab3['DenominazioneAttivit√†'].unique() if pd.notna(d)])
                                
                                # Visualizza il filtro per denominazione attivit√†
                                with filter_denominazione_col1:
                                    denominazione_sel = st.selectbox(f"üìù Seleziona Denominazione Attivit√†:", 
                                                                   ["Tutte"] + denominazione_list, 
                                                                   key="filt_denominazione_tab3")
                                
                                # Mostra il numero di record per questa denominazione
                                if denominazione_sel != "Tutte":
                                    with filter_denominazione_col2:
                                        record_per_denominazione = len(current_df_for_tab3[current_df_for_tab3['DenominazioneAttivit√†'] == denominazione_sel])
                                        st.metric("Record trovati", record_per_denominazione)
                            else:
                                with filter_denominazione_col1:
                                    st.warning("Colonna 'DenominazioneAttivit√†' non presente nei dati")
                        except Exception as e:
                            st.error(f"Errore nel filtro denominazione attivit√†: {e}")

                        # --- Filtro Studente (solo se percorso specifico √® selezionato) ---
                        stud_sel = "Tutti gli Studenti" # Default
                        if perc_sel != "Tutti":
                            # Preparazione lista studenti per il filtro
                            temp_df_for_student_list = attendance_df[attendance_df[p_col_disp_key] == perc_sel].copy()
                            
                            if not temp_df_for_student_list.empty:
                                temp_df_for_student_list['StudentIdentifier'] = temp_df_for_student_list.apply(
                                    lambda row: f"{row.get('Cognome','')} {row.get('Nome','')} ({row.get('CodiceFiscale','N/A')})".strip(), axis=1
                                )
                                student_list = sorted(temp_df_for_student_list['StudentIdentifier'].unique())
                                
                                # Statistica totale studenti per questo percorso
                                with filter_col2:
                                    st.metric("Studenti nel percorso", len(student_list))
                                
                                # Filtro studenti con ricerca
                                search_placeholder = "Cerca per nome o cognome..."
                                search_term = st.text_input("üîé Cerca studente:", placeholder=search_placeholder, key="search_student")
                                
                                if search_term:
                                    search_term = search_term.lower()
                                    filtered_student_list = [s for s in student_list if search_term in s.lower()]
                                    st.caption(f"Trovati {len(filtered_student_list)} studenti su {len(student_list)}")
                                    student_options = ["Tutti gli Studenti"] + filtered_student_list
                                else:
                                    student_options = ["Tutti gli Studenti"] + student_list
                                
                                stud_sel = st.selectbox("üë§ Seleziona Studente:", student_options, key="filt_stud_tab3_v7")
                            else:
                                st.info(f"Nessun dato aggregato trovato per il percorso '{perc_sel}'.")
                                df_to_display_agg = pd.DataFrame()
                                df_to_display_detail = pd.DataFrame()

                        # Se il filtro percorso √® "Tutti"
                        else:
                            df_to_display_agg = attendance_df.copy()
                            df_to_display_detail = current_df_for_tab3.copy()
                        
                        # --- Applicazione Filtri in Sequenza ---
                        st.divider()
                        st.subheader("üîç Risultati Filtrati", divider="gray")
                        
                        # Filtriamo per percorso se selezionato
                        if perc_sel != "Tutti":
                            df_to_display_agg = attendance_df[attendance_df[p_col_disp_key] == perc_sel].copy()
                            df_to_display_detail = current_df_for_tab3[current_df_for_tab3[p_col_internal_key] == perc_sel].copy()
                        else:
                            df_to_display_agg = attendance_df.copy()
                            df_to_display_detail = current_df_for_tab3.copy()
                        
                        # Contatore record dopo filtro percorso
                        num_record_dopo_filtro_percorso = len(df_to_display_agg)
                        
                        # Applica filtro per Codice Classe di concorso se selezionato
                        if codice_concorso_sel != "Tutti" and 'Codice_Classe_di_concorso' in df_to_display_agg.columns:
                            df_to_display_agg = df_to_display_agg[df_to_display_agg['Codice_Classe_di_concorso'] == codice_concorso_sel].copy()
                            if 'Codice_Classe_di_concorso' in df_to_display_detail.columns:
                                df_to_display_detail = df_to_display_detail[df_to_display_detail['Codice_Classe_di_concorso'] == codice_concorso_sel].copy()
                        
                        # Contatore record dopo filtro codice concorso
                        num_record_dopo_filtro_codice = len(df_to_display_agg)
                        
                        # Applica filtro per Denominazione Attivit√† se selezionato
                        if denominazione_sel != "Tutte" and 'DenominazioneAttivit√†' in df_to_display_detail.columns:
                            df_to_display_detail = df_to_display_detail[df_to_display_detail['DenominazioneAttivit√†'] == denominazione_sel].copy()
                            # Per i dati aggregati, filtriamo in base ai codici fiscali che hanno quella denominazione
                            if not df_to_display_detail.empty and 'CodiceFiscale' in df_to_display_detail.columns and 'CodiceFiscale' in df_to_display_agg.columns:
                                codici_fiscali_filtrati = df_to_display_detail['CodiceFiscale'].unique()
                                df_to_display_agg = df_to_display_agg[df_to_display_agg['CodiceFiscale'].isin(codici_fiscali_filtrati)].copy()
                        
                        # Contatore record dopo filtro denominazione
                        num_record_dopo_filtro_denom = len(df_to_display_agg)
                        
                        # Applica filtro per studente se selezionato
                        if stud_sel != "Tutti gli Studenti" and perc_sel != "Tutti":
                            try:
                                selected_cf = re.search(r'\((.*?)\)', stud_sel).group(1)
                                df_to_display_agg = df_to_display_agg[df_to_display_agg['CodiceFiscale'] == selected_cf].copy()
                                df_to_display_detail = df_to_display_detail[df_to_display_detail['CodiceFiscale'] == selected_cf].copy()
                            except (AttributeError, IndexError):
                                st.warning("Formato studente non riconosciuto nel filtro.")
                        
                        # Contatore record dopo filtro studente
                        num_record_dopo_filtro_stud = len(df_to_display_agg)
                        
                        # Mostriamo statistiche sui filtri applicati
                        with st.expander("üìä Statistiche Filtri", expanded=False):
                            stats_col1, stats_col2, stats_col3, stats_col4 = st.columns(4)
                            with stats_col1:
                                st.metric("Dopo filtro percorso", num_record_dopo_filtro_percorso)
                            with stats_col2:
                                st.metric("Dopo filtro codice", num_record_dopo_filtro_codice)
                            with stats_col3:
                                st.metric("Dopo filtro denom.", num_record_dopo_filtro_denom)
                            with stats_col4:
                                st.metric("Record finali", num_record_dopo_filtro_stud)

                        try:
                            # --- Visualizzazione Tabelle ---
                            if not df_to_display_agg.empty:
                                # Aggiungi un separatore e un container per le tabelle
                                tables_container = st.container()
                                
                                with tables_container:
                                    # Statistiche riassuntive
                                    if perc_sel != "Tutti" and stud_sel == "Tutti gli Studenti":
                                        st.markdown("### üìä Statistiche del percorso")
                                        stats_col1, stats_col2, stats_col3, stats_col4 = st.columns(4)
                                        
                                        with stats_col1:
                                            avg_presenze = df_to_display_agg['Presenze'].mean()
                                            st.metric("Media Presenze", f"{avg_presenze:.1f}")
                                        
                                        with stats_col2:
                                            max_presenze = df_to_display_agg['Presenze'].max()
                                            st.metric("Presenze Max", f"{max_presenze}")
                                            
                                        with stats_col3:
                                            min_presenze = df_to_display_agg['Presenze'].min()
                                            st.metric("Presenze Min", f"{min_presenze}")
                                        
                                        with stats_col4:
                                            tot_studenti = len(df_to_display_agg)
                                            st.metric("Totale Studenti", tot_studenti)
                                    
                                    # Titolo della tabella
                                    if perc_sel == "Tutti":
                                        st.subheader("üìã Riepilogo Aggregato - Tutti i Percorsi", divider="blue")
                                    else: # Percorso selezionato, ma tutti gli studenti
                                        st.subheader(f"üìã Riepilogo Aggregato - {perc_sel}", divider="blue")

                                    cols_disp_agg = ['CodiceFiscale', 'Nome', 'Cognome', 'Email', 
                                                    'Percorso', 'Codice_Classe_di_concorso', 'Dipartimento', 'Matricola',
                                                    p_col_disp_key, 'Percorso Elaborato (Info)', 'CFU Totali', 'Presenze']
                                    cols_disp_agg_exist = [c for c in cols_disp_agg if c in df_to_display_agg.columns]
                                    sort_agg_by = [p_col_disp_key, 'Cognome', 'Nome'] if perc_sel == "Tutti" else ['Cognome', 'Nome']
                                    
                                    # Opzioni di visualizzazione e ordinamento
                                    visual_options_col1, visual_options_col2 = st.columns(2)
                                    
                                    with visual_options_col1:
                                        sort_options = ["Presenze (decrescente)", "Cognome e Nome", "Percorso", "Codice Classe di concorso"]
                                        selected_sort = st.radio("Ordinamento tabella:", sort_options, horizontal=True)
                                    
                                    with visual_options_col2:
                                        highlight_opt = st.checkbox("Evidenzia valori critici", value=True, 
                                                                  help="Evidenzia studenti con poche presenze")
                                    
                                    # Applica l'ordinamento selezionato
                                    if selected_sort == "Presenze (decrescente)" and 'Presenze' in df_to_display_agg.columns:
                                        df_to_show = df_to_display_agg[cols_disp_agg_exist].sort_values(by=['Presenze'], ascending=False)
                                    elif selected_sort == "Cognome e Nome" and 'Cognome' in df_to_display_agg.columns:
                                        df_to_show = df_to_display_agg[cols_disp_agg_exist].sort_values(by=['Cognome', 'Nome'])
                                    elif selected_sort == "Percorso" and p_col_disp_key in df_to_display_agg.columns:
                                        df_to_show = df_to_display_agg[cols_disp_agg_exist].sort_values(by=[p_col_disp_key, 'Cognome', 'Nome'])
                                    elif selected_sort == "Codice Classe di concorso" and 'Codice_Classe_di_concorso' in df_to_display_agg.columns:
                                        df_to_show = df_to_display_agg[cols_disp_agg_exist].sort_values(by=['Codice_Classe_di_concorso', 'Cognome', 'Nome'])
                                    elif sort_agg_by:
                                        valid_sort_agg_by = [c for c in sort_agg_by if c in df_to_display_agg.columns]
                                        if valid_sort_agg_by:
                                            df_to_show = df_to_display_agg[cols_disp_agg_exist].sort_values(by=valid_sort_agg_by)
                                        else:
                                            df_to_show = df_to_display_agg[cols_disp_agg_exist]
                                    else:
                                        df_to_show = df_to_display_agg[cols_disp_agg_exist]
                                    
                                    # Dataframe con styling condizionale
                                    if highlight_opt and 'Presenze' in df_to_show.columns:
                                        # Crea una maschera per le presenze basse (< 4)
                                        def highlight_low_attendance(val):
                                            if isinstance(val, (int, float)) and val < 4:
                                                return 'background-color: #ffcccc'
                                            return ''
                                        
                                        # Applica lo styling solo alla colonna Presenze
                                        styled_df = df_to_show.style.applymap(
                                            highlight_low_attendance, subset=['Presenze']
                                        )
                                        st.dataframe(styled_df, use_container_width=True)
                                    else:
                                        st.dataframe(df_to_show, use_container_width=True)


                            if not df_to_display_detail.empty:
                                # Sezione per il dettaglio delle presenze
                                detail_container = st.container()
                                with detail_container:
                                    # Titolo della sezione dettaglio
                                    if perc_sel == "Tutti":
                                        st.subheader("üìù Dettaglio Record Presenze - Tutti i Percorsi", divider="blue")
                                    else:
                                        st.subheader(f"üìù Dettaglio Record Presenze - {perc_sel}", divider="blue")
                                        if stud_sel != "Tutti gli Studenti":
                                            st.caption(f"Studente selezionato: {stud_sel}")
                                    
                                    # Riepilogo record trovati e statistiche dettaglio
                                    record_count = len(df_to_display_detail)
                                    if record_count > 0:
                                        detail_stats_col1, detail_stats_col2 = st.columns(2)
                                        
                                        with detail_stats_col1:
                                            st.info(f"Trovati {record_count} record di presenza", icon="‚ÑπÔ∏è")
                                            
                                        # Se ci sono date, mostra il periodo
                                        if 'DataPresenza' in df_to_display_detail.columns:
                                            with detail_stats_col2:
                                                try:
                                                    min_data = pd.to_datetime(df_to_display_detail['DataPresenza']).min()
                                                    max_data = pd.to_datetime(df_to_display_detail['DataPresenza']).max()
                                                    st.info(f"Periodo: dal {min_data.strftime('%d/%m/%Y')} al {max_data.strftime('%d/%m/%Y')}", icon="üìÖ")
                                                except:
                                                    pass
    
                                    # Colonne da visualizzare
                                    cols_disp_detail = ['CodiceFiscale', 'Cognome', 'Nome', 'Email', 'DataPresenza', 'OraPresenza', 
                                                       'Percorso', 'Codice_Classe_di_concorso', 'Dipartimento',
                                                       'DenominazioneAttivit√†', 'CFU', 'PercorsoInternal']
                                    cols_disp_detail_exist = [c for c in cols_disp_detail if c in df_to_display_detail.columns]
                                    
                                    # Ordinamento
                                    detail_sort_options = st.radio(
                                        "Ordinamento dettagli:", 
                                        ["Per Data (pi√π recente prima)", "Per Cognome e Nome", "Per Attivit√†", "Per Codice Classe di concorso"],
                                        horizontal=True
                                    )
                                    
                                    # Imposta l'ordinamento in base alla selezione
                                    if detail_sort_options == "Per Data (pi√π recente prima)" and 'DataPresenza' in df_to_display_detail.columns:
                                        sort_by_columns = ['DataPresenza', 'OraPresenza'] 
                                        ascending = [False, False]  # Prima le date pi√π recenti
                                    elif detail_sort_options == "Per Attivit√†" and 'DenominazioneAttivit√†' in df_to_display_detail.columns:
                                        sort_by_columns = ['DenominazioneAttivit√†', 'DataPresenza']
                                        ascending = [True, True]
                                    elif detail_sort_options == "Per Codice Classe di concorso" and 'Codice_Classe_di_concorso' in df_to_display_detail.columns:
                                        sort_by_columns = ['Codice_Classe_di_concorso', 'Cognome', 'Nome']
                                        ascending = [True, True, True]
                                    else:  # Default: per cognome e nome
                                        sort_by_columns = ['Cognome', 'Nome']
                                        if perc_sel == "Tutti": sort_by_columns.insert(0, p_col_internal_key)
                                        if 'DataPresenza' in df_to_display_detail.columns: sort_by_columns.append('DataPresenza')
                                        ascending = [True] * len(sort_by_columns)
                                    
                                    # Filtra colonne valide per ordinamento
                                    valid_sort_by = [col for col in sort_by_columns if col in df_to_display_detail.columns]
                                    
                                    # Visualizza dataframe
                                    if not valid_sort_by: 
                                        df_to_show = df_to_display_detail[cols_disp_detail_exist]
                                    else: 
                                        df_to_show = df_to_display_detail[cols_disp_detail_exist].sort_values(
                                            by=valid_sort_by, 
                                            ascending=ascending[:len(valid_sort_by)]
                                        )
                                    
                                    st.dataframe(df_to_show, use_container_width=True)
                            else:
                                if perc_sel != "Tutti": st.info("Nessun record dettagliato da mostrare per la selezione corrente.")
                        except Exception as e: 
                            st.error(f"Errore durante la visualizzazione: {e}")

            # --- Esportazione Excel Multi-Tab ---
            st.divider()
            
            # Utilizziamo un container per la sezione di esportazione
            export_container = st.container()
            with export_container:
                st.subheader("üì§ Esportazione Dettaglio Presenze", divider="gray")
                course_col_export = 'PercorsoOriginaleSenzaArt13Internal'
                if course_col_export not in current_df_for_tab3.columns:
                    st.error(f"Colonna chiave '{course_col_export}' non trovata.")
                else:
                    export_description_col, export_info_col = st.columns([2, 1])
                    with export_description_col:
                        st.write("Questa funzione consente di esportare i dati dettagliati in Excel o CSV.")
                    
                    with export_info_col:
                        with st.expander("Informazioni Esportazione"):
                            st.info("L'esportazione Excel crea un foglio separato per ogni percorso.\nIl nome del foglio viene estratto dal codice del percorso.")
                    
                    # Tab per i due tipi di export
                    export_tab1, export_tab2 = st.tabs(["üóÇÔ∏è Export Multi-Foglio", "üìä Export CSV"])
                
                    with export_tab1:
                        st.markdown("**1Ô∏è‚É£ Seleziona e Ordina le Colonne:**")
                        st.caption("Seleziona le colonne e trascinale per cambiarne l'ordine")

                        all_possible_cols = current_df_for_tab3.columns.tolist()
                        internal_cols_to_exclude = ['TimestampPresenza']
                        all_exportable_cols = [col for col in all_possible_cols if col not in internal_cols_to_exclude]
                        default_cols_export_ordered = ['DataPresenza','OraPresenza','DenominazioneAttivit√†','Cognome','Nome','Email','PercorsoInternal','PercorsoOriginaleSenzaArt13Internal','CFU']
                        default_cols_final = [col for col in default_cols_export_ordered if col in all_exportable_cols]

                        # Miglioriamo la visualizzazione dei dati di esempio
                        with st.expander("üëÄ Anteprima dati (primo record)"):
                            if not current_df_for_tab3.empty:
                                example_data = current_df_for_tab3.head(1)[all_exportable_cols].to_dict(orient='records')[0]
                                st.json(example_data)
                            else: 
                                st.caption("Nessun dato da mostrare.")

                        # Selezione colonne con una descrizione pi√π chiara
                        st.caption("Le colonne selezionate verranno incluse nell'esportazione nell'ordine specificato")
                        selected_cols_export_ordered = st.multiselect(
                            "Seleziona le colonne da esportare:", 
                            options=all_exportable_cols, 
                            default=default_cols_final, 
                            key="export_cols_selector_ordered_v215"
                        )
                        
                        st.markdown("**2Ô∏è‚É£ Seleziona Periodo per l'Export (opzionale):**")
                        col1_date, col2_date = st.columns(2)
                        
                        with col1_date:
                            # Determina la data minima e massima nel dataset
                            min_date = None
                            if not current_df_for_tab3.empty and 'DataPresenza' in current_df_for_tab3.columns:
                                valid_dates = current_df_for_tab3['DataPresenza'].dropna()
                                if not valid_dates.empty:
                                    try:
                                        min_date = valid_dates.min()
                                        if not isinstance(min_date, date):
                                            min_date = pd.to_datetime(min_date).date() if not pd.isna(min_date) else None
                                    except Exception as e:
                                        st.warning(f"Problema con date: {e}")
                                        min_date = None
                            
                            start_date = st.date_input("Data inizio:", value=min_date, key="export_start_date", help="Lascia vuoto per includere tutti i dati dall'inizio")
                        
                        with col2_date:
                            # Determina la data massima
                            max_date = None
                            if not current_df_for_tab3.empty and 'DataPresenza' in current_df_for_tab3.columns:
                                valid_dates = current_df_for_tab3['DataPresenza'].dropna()
                                if not valid_dates.empty:
                                    try:
                                        max_date = valid_dates.max()
                                        if not isinstance(max_date, date):
                                            max_date = pd.to_datetime(max_date).date() if not pd.isna(max_date) else None
                                    except Exception as e:
                                        max_date = None
                            
                            end_date = st.date_input("Data fine:", value=max_date, key="export_end_date", help="Lascia vuoto per includere tutti i dati fino alla fine")

                        # Mostra periodo selezionato
                        if start_date is not None or end_date is not None:
                            date_filter_text = "Periodo selezionato: "
                            if start_date is not None:
                                date_filter_text += f"dal {start_date.strftime('%d/%m/%Y')}"
                            else:
                                date_filter_text += "dall'inizio"
                            if end_date is not None:
                                date_filter_text += f" al {end_date.strftime('%d/%m/%Y')}"
                            else:
                                date_filter_text += " alla fine"
                            
                            st.info(date_filter_text)
                        
                        # Pulsante per generare ed esportare file Excel
                        if st.button("üìä Genera ed Esporta File Excel", key="export_excel_ordered_v215", use_container_width=True):
                            if not selected_cols_export_ordered: 
                                st.warning("Seleziona almeno una colonna.")
                            else:
                                overall_success = True
                                sheets_written = 0
                                error_messages = []
                                try:
                                    output = BytesIO()
                                    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                                        unique_courses = current_df_for_tab3[course_col_export].unique()
                                        unique_courses = sorted([str(c) for c in unique_courses if pd.notna(c)])
                                        if not unique_courses: 
                                            st.error(f"Nessun valore unico trovato in '{course_col_export}'.")
                                            overall_success = False
                                        else:
                                            prog_bar = st.progress(0, text="Creazione fogli...")
                                            for i, course_value in enumerate(unique_courses):
                                                # Cerca prima per il nuovo formato [codice]
                                                code_match = re.search(r'^\[([-\w]+)\]', course_value)
                                                if code_match:
                                                    extracted_code = code_match.group(1)
                                                    sheet_name_cleaned = clean_sheet_name(extracted_code)
                                                else:
                                                    # Fallback al metodo precedente di estrazione dalle parentesi
                                                    extracted_code = extract_code_from_parentheses(course_value)
                                                    if extracted_code: 
                                                        sheet_name_cleaned = clean_sheet_name(extracted_code)
                                                    else: 
                                                        sheet_name_cleaned = clean_sheet_name(course_value)
                                                        st.caption(f"Nota: Codice non trovato per '{course_value}', usato nome completo.")
                                                
                                                prog_text = f"Foglio: {sheet_name_cleaned} ({i+1}/{len(unique_courses)})" 
                                                prog_bar.progress((i + 1) / len(unique_courses), text=prog_text)
                                                df_sheet = current_df_for_tab3[current_df_for_tab3[course_col_export] == course_value].copy()
                                                
                                                if df_sheet.empty: 
                                                    st.write(f"Info: Nessun dato per '{sheet_name_cleaned}', foglio saltato.")
                                                    continue
                                                
                                                # Filtro per periodo di data se selezionato
                                                if 'DataPresenza' in df_sheet.columns:
                                                    date_filtered = False
                                                    if 'export_start_date' in st.session_state and st.session_state.export_start_date is not None:
                                                        start_date = st.session_state.export_start_date
                                                        df_sheet = df_sheet[df_sheet['DataPresenza'] >= start_date]
                                                        date_filtered = True
                                                    
                                                    if 'export_end_date' in st.session_state and st.session_state.export_end_date is not None:
                                                        end_date = st.session_state.export_end_date
                                                        df_sheet = df_sheet[df_sheet['DataPresenza'] <= end_date]
                                                        date_filtered = True
                                                    
                                                    if date_filtered and df_sheet.empty:
                                                        st.write(f"Info: Nessun dato per '{sheet_name_cleaned}' nel periodo selezionato, foglio saltato.")
                                                        continue
                                                
                                                final_ordered_cols_for_sheet = [col for col in selected_cols_export_ordered if col in df_sheet.columns]
                                                if not final_ordered_cols_for_sheet: 
                                                    st.write(f"Info: Nessuna colonna selezionata trovata per '{sheet_name_cleaned}', foglio saltato.")
                                                    continue
                                                    
                                                df_sheet_export = df_sheet[final_ordered_cols_for_sheet]
                                                if df_sheet_export.empty: 
                                                    st.write(f"Info: Nessun dato per '{sheet_name_cleaned}' dopo selezione colonne, foglio saltato.")
                                                    continue
                                                    
                                                try:
                                                    rename_map_export = {
                                                        'PercorsoInternal': 'Tipo Percorso', 
                                                        'PercorsoOriginaleInternal': 'Percorso Originale Input', 
                                                        'PercorsoOriginaleSenzaArt13Internal': 'Denominazione Percorso', 
                                                        'DenominazioneAttivitaNormalizzataInternal': 'Attivit√† Elaborata'
                                                    }
                                                    cols_to_rename_final = {k: v for k, v in rename_map_export.items() if k in df_sheet_export.columns}
                                                    df_sheet_export = df_sheet_export.rename(columns=cols_to_rename_final)
                                                    df_sheet_export.to_excel(writer, sheet_name=sheet_name_cleaned, index=False)
                                                    sheets_written += 1
                                                except Exception as sheet_error: 
                                                    error_msg = f"Errore scrittura foglio '{sheet_name_cleaned}': {sheet_error}"
                                                    st.warning(error_msg)
                                                    error_messages.append(error_msg)
                                                    overall_success = False
                                except Exception as writer_error: 
                                    st.error(f"Errore generale creazione Excel: {writer_error}")
                                    st.exception(writer_error)
                                    overall_success = False
                                    
                                if overall_success and sheets_written > 0:
                                    prog_bar.progress(1.0, text="Completato!")
                                    output.seek(0)
                                    ts = datetime.now().strftime("%Y%m%d_%H%M")
                                    
                                    # Aggiungi informazioni sul periodo al nome del file
                                    period_info = ""
                                    if 'export_start_date' in st.session_state and st.session_state.export_start_date is not None:
                                        start_str = st.session_state.export_start_date.strftime("%Y%m%d")
                                        period_info += f"_dal{start_str}"
                                    if 'export_end_date' in st.session_state and st.session_state.export_end_date is not None:
                                        end_str = st.session_state.export_end_date.strftime("%Y%m%d")
                                        period_info += f"_al{end_str}"
                                    
                                    fname = f"Report_Presenze_Dettaglio_PercorsoSenzaArt13{period_info}_{ts}.xlsx"
                                    st.success(f"File Excel generato con {sheets_written} fogli!")
                                    if error_messages: 
                                        st.warning("Alcuni fogli potrebbero aver avuto problemi:")
                                        [st.caption(msg) for msg in error_messages]
                                        
                                    st.download_button(
                                        label="üì• Scarica Report Excel Dettaglio",
                                        data=output,
                                        file_name=fname,
                                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                                        key="dl_excel_course_ordered_v215",
                                        use_container_width=True
                                    )
                                elif sheets_written == 0 and overall_success: 
                                    st.warning("Nessun dato trovato per alcun percorso. File Excel non generato.")
                                else:
                                    st.error("Generazione file Excel fallita o nessun foglio valido scritto.")
                                    if error_messages: 
                                        st.warning("Dettaglio errori:")
                                        [st.caption(msg) for msg in error_messages]
                
                    with export_tab2:
                        st.markdown("**Esportazione in CSV**")
                        st.caption("Il file CSV conterr√† tutti i dati in un'unica tabella, filtrati per il periodo selezionato")
                        
                        # Pulsante per generare ed esportare file CSV
                        if st.button("üìÑ Genera ed Esporta File CSV", key="export_csv_ordered_v215", use_container_width=True):
                            if not selected_cols_export_ordered: 
                                st.warning("Seleziona almeno una colonna.")
                            else:
                                # Filtra i dati in base al periodo se selezionato
                                filtered_df = current_df_for_tab3.copy()
                                date_filtered = False
                                
                                if 'export_start_date' in st.session_state and st.session_state.export_start_date is not None and 'DataPresenza' in filtered_df.columns:
                                    start_date = st.session_state.export_start_date
                                    filtered_df = filtered_df[filtered_df['DataPresenza'] >= start_date]
                                    date_filtered = True
                                
                                if 'export_end_date' in st.session_state and st.session_state.export_end_date is not None and 'DataPresenza' in filtered_df.columns:
                                    end_date = st.session_state.export_end_date
                                    filtered_df = filtered_df[filtered_df['DataPresenza'] <= end_date]
                                    date_filtered = True
                                
                                if filtered_df.empty:
                                    st.warning("Nessun dato disponibile per il periodo selezionato.")
                                else:
                                    # Prendi solo le colonne selezionate
                                    final_ordered_cols = [col for col in selected_cols_export_ordered if col in filtered_df.columns]
                                    
                                    if not final_ordered_cols:
                                        st.warning("Nessuna delle colonne selezionate √® presente nei dati.")
                                    else:
                                        # Prepara il CSV con le colonne selezionate e rinominate
                                        df_export = filtered_df[final_ordered_cols]
                                        rename_map = {
                                            'PercorsoInternal': 'Tipo Percorso', 
                                            'PercorsoOriginaleInternal': 'Percorso Originale Input', 
                                            'PercorsoOriginaleSenzaArt13Internal': 'Denominazione Percorso', 
                                            'DenominazioneAttivitaNormalizzataInternal': 'Attivit√† Elaborata'
                                        }
                                        cols_to_rename = {k: v for k, v in rename_map.items() if k in df_export.columns}
                                        df_export = df_export.rename(columns=cols_to_rename)
                                        
                                        # Esporta in CSV
                                        csv_data = df_export.to_csv(index=False).encode('utf-8')
                                        ts = datetime.now().strftime("%Y%m%d_%H%M")
                                        
                                        # Aggiungi informazioni sul periodo al nome del file
                                        period_info = ""
                                        if 'export_start_date' in st.session_state and st.session_state.export_start_date is not None:
                                            start_str = st.session_state.export_start_date.strftime("%Y%m%d")
                                            period_info += f"_dal{start_str}"
                                        if 'export_end_date' in st.session_state and st.session_state.export_end_date is not None:
                                            end_str = st.session_state.export_end_date.strftime("%Y%m%d")
                                            period_info += f"_al{end_str}"
                                        
                                        fname_csv = f"Report_Presenze_Dettaglio{period_info}_{ts}.csv"
                                        st.success(f"File CSV generato con {len(filtered_df)} record!")
                                        st.download_button(
                                            label="üì• Scarica Report CSV",
                                            data=csv_data,
                                            file_name=fname_csv,
                                            mime="text/csv",
                                            key="dl_csv_ordered_v215",
                                            use_container_width=True
                                        )
                
                # Footer della pagina
                if not attendance_df.empty:
                    # Footer con informazioni aggiuntive
                    st.divider()
                    footer_container = st.container()
                    with footer_container:
                        footer_col1, footer_col2 = st.columns(2)
                        
                        # Messaggio informativo sulle colonne che saranno rimosse in futuro
                        with footer_col1:
                            with st.expander("‚ö†Ô∏è Nota sui campi che saranno rimossi in futuro"):
                                st.warning("""
                                I seguenti campi saranno rimossi in future versioni:
                                - PercorsoOriginaleInternal
                                - PercorsoOriginaleSenzaArt13Internal
                                - PercorsoInternal
                                """)
                                
                        # Aiuto sulla funzionalit√†
                        with footer_col2:
                            with st.expander("‚ÑπÔ∏è Informazioni su questa pagina"):
                                st.info("""
                                **Funzionalit√† della scheda Calcolo Presenze**
                                
                                In questa scheda puoi:
                                1. Filtrare i dati per percorso e studente
                                2. Visualizzare statistiche aggregate sulle presenze
                                3. Ordinare i dati in diversi modi
                                4. Esportare i dati in Excel o CSV
                                
                                L'esportazione consente di creare report dettagliati per ogni percorso.
                                """)
                else:
                    st.warning("Nessun dato di presenza aggregato da visualizzare. Verifica che i dati siano stati caricati correttamente.", icon="‚ö†Ô∏è")
    else:
        st.error("Nessun dato valido caricato. Carica un file valido nella prima scheda dell'applicazione.", icon="üö´")
